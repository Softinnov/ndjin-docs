#summary Ndjin instance webservices


= getInstances =

|| Security || Open ||
|| Input ||  `ownerId`, `ownerFieldName`, `packagePath`, `start`, `count`, `viewFieldNames`, `deepFieldNames`, `filters`, `filtersOperator`, `sortByFieldNames`, `viewStateNames` ||
|| Output || `instances`, `totalCount`, `siteName`, `stateNames` ||

Result a list of instance.
Following steps are executed to build the result:
  * get an list of instance according to `ownerId`, `ownerFieldName`, `packagePath`
  * filter this list applying `filters`, `filtersOperator`
  * sort the list using `sortByFieldNames`
  * keep `totalCount` of the list
  * apply 'View' transition on each item in the list starting at `start` until the sublist list reach `count` size
  * copy each instance value of sublist in result list `viewFieldNames`, `deepFieldNames`
  * build  `stateNames` list of states name of resulting instance

Instances returned are reduced value object with selected field. Each instance contains also internal fields:
  * `id` persistent unique id of the instance
  * `stateId` referring to id of a state model object
  * `dataTypeId` referring to the id of a dataType mode object

_Internal values are returned as `_id`, `_stateId` and `_dataTypeId` object fieldname when using JSON format and as element attribute in XML format._


Input value
  * ownerFieldName: name of dataType field pointing to a a collection of instances

Optional input values
  * ownerId: instance id number from where the query is performed (if none is provided, the query is performed on application singleton)
  * start: start number from where it should retrieve item
  * count: number of item to get back in list
  * packagePath: field path string to a package singleton (in of having many package singleton in application)
  * viewFieldNames: array of string containing field name that should be returned
  * deepFieldNames: array of string containing field name of sub instance (in case of an object relation association)
  * filters: array of filter object
  * filtersOperator: operator applied to each element of filters object (if none provided then AND is applyed)
  * sortByFieldNames: array of sort object
  * viewStateNames: boolean true if result should contain an array of all state id/name returned in result


Output values
  * instances: list of resulting instance eventually sorted
  * totalCount: total result count after filters and before applying start/count and 'View' transition applyed
  * stateNames: a list of id/state name containing all name related to all state id mentioned in instance result
Optional output value
  * stateNames: array of all state object ( id/name) returned in result



=== Filters === 

You can limit the result by applying a list of filters to the query.
Each item object in list of filter could be
  * a filter list item having:
    * `filters`: a list of filter object
    * `filtersOperator`: operator applied between item object of the `filters`, could be `AND` or `OR`
  * a filter item object having:
    * `fieldName`: a string with dataType field name
    * `operator` : a string (see below)
    * `value`:  any primitive type (string, number, boolean) to be compared



Filter item `operator` are:
|| `operator` || Description ||
|| `==` || strict equal (case sensitive for string)  ||
|| `!=` ||  strict not equal (case sensitive for string) ||
|| `=~` || equals ignore case ||
|| `=%` || contains ||
|| `>` ||  greater than (case insensitive for string) ||
|| `>=` || greater than or equals (case insensitive for string) ||
|| `<` || lower than (case insensitive for string) ||
|| `<=` || lower than or equals (case insensitive for string) ||



=== Sort ===

Result can be sorted using `sortByFieldNames` list.
Each item object of `sortByFieldNames` has: 
  * `sortBy`: a field name string
  * `sortAscOrder`: boolean if true then sort with be in ascending order


=== Example using Javascript[http://jquery.org JQuery]/JSONP/[http://www.JSON.org/json2.js JSON2] ===

{{{
// build the query object
query = {
  ownerFieldName: "contacts",
  count: 10,

  filters: [
    { fieldName: "name", operator: "=%", value: "Bill" },
    { fieldName: "age", operator: ">", value: 18 }
  ],
  filtersOperator: "AND",

  sortByFieldNames: [ { sortBy: "name", sortAscOrder: true } ],

  viewFieldNames: [ "name", "age", "nickname" ]

};

// do the HTTP request
$.ajax({
  url: "http://myapp.ndjin.net/ng/service/InstanceService/getInstances",
  dataType: "jsonp",
  data: { requestDataType:'json', responseDataType:'jsonp', data: JSON.stringify( query ) },
  success: function (data, textStatus) {
    result = data.result.instances;
  }
}); // ajax
}}}






= applyTransitionsToInstance =

_Could also be `applyTransitionToInstance`_

|| Security || Open ||
|| Input ||  `instance`, `appliedTransitionNames`, `ownerId`, `ownerFieldName`, `packagePath`, `viewFieldNames`, `deepFieldNames` ||
|| Output || `instance`, `siteName` ||

Apply transitions to the given instance.
According to the current state of the instance and the transition defined at his state, a transition is applied on this instance.

When a transition is applied, an set of operation can be executed. Those operation may required some parameters to be properly executed.
Those parameters should also be provided in input object.

Each operation are individually executed inside a transaction meaning that if an instance is modified during the execution of an operation, all modified value are saved transactionnally.
So the whole transition is not transaction (for performance reasons). If you need to have complete set of operation executed in a transactionnal context, you should define an operation that will itself call other operation, in this case the transaction will be propagated.
If one operation fails (generating an exception) the transition is not applied but, each previous modifications that might have occurs in other operation, still remains. So it is better practice to set security and safety check operation on top of operations list and apply modification at last operation execution.


Input value
  * instance: object instance on which transitions will be applied
  * appliedTransitionNames: list of string containing the transition name successively applied to the given instance
  * ownerFieldName: name of dataType field pointing to a a collection of instances (_will not be mandatory soon_)

Optional input values

  * viewFieldNames: array of string containing field name that should be returned
  * deepFieldNames: array of string containing field name of sub instance (in case of an object relation association)

Common instance operation optional input values
  * ownerId: instance id number of the owner (parent) of the instance (if none is provided, the query is performed on application singleton)
  * packagePath: field path string to a package singleton (in of having many package singleton in application)


Output values
  * instance: instance after transitions applied
  * siteName: site name on witch transition has been applyed (_might be considered as redundent_)



=== Example using Javascript[http://jquery.org JQuery]/JSONP/[http://www.JSON.org/json2.js JSON2] ===


{{{
// build the query to apply 'New' and 'Store' transitions on the given instance that will be appended to contacts property of Application singleton instance
var query = { 
 ownerFieldName: 'contacts',
 appliedTransitionNames: ['New', 'Store'],
  instance: {
    name: 'MySelf',
    telephone: '0123456789'
  }
};

// do the HTTP request
$.ajax({
  url: "http://myapp.ndjin.net/ng/service/InstanceService/getInstances",
  dataType: "jsonp",
  data: { requestDataType:'json', responseDataType:'jsonp', data: JSON.stringify( query ) },
  success: function (data, textStatus) {
    result = data.result.instance;
  } // success
}); // ajax     

}}}

