#summary simple blog application tutorial


= Prerequisite =

You need to register an [http://openid.net/get/ OpenID] and create an application site on [http://ndjin.net ndjin platform].
Once your application site your have URL to refer to it such as: `http://[your application site name].ndjin.net/ng/`

You can get the source of this tutorial [http://code.google.com/p/ndjin/source/browse/#svn/trunk/js/blog here].

= Authenticate yourself =

You have to authenticate yourself to get the required right to operate on your application site.
Just make a request with your browser to the url `http://[your application site name].ndjin.net/ng/auth` and pass 2 parameters:
  * openID: your OpenID (such as `https://me.yahoo.com/[your login]` for Yahoo or `https://www.google.com/accounts/o8/id/[your google email]` for Google)
  * returnURL: the URL your browser will be redirected after authenticated

For example :
http://yourdomainname.ndjin.net/ng/auth?openID=yourOpenId&returnURL=http://yourhost/currentpage


= Create Your Model =

We create a simple Blog model having Article, Topic and Comment based on this diagram.

[http://ndjin.googlecode.com/svn/trunk/js/blog/admin/blogModel.png]

You can view the full JS script [http://code.google.com/p/ndjin/source/browse/trunk/js/blog/admin/createModel.html here].

We first create the Topic class:

{{{
var dataType = {
	name: 'Topic',
	inheritedDataTypeId: model.getDataTypeIdByName( 'Object' ),
	fields: [
		{ name: 'name', dataTypeId: model.getDataTypeIdByName( 'Text' ), min: 1, max: 1, unique: true, preview: true }
	]
}
model.createOrUpdateDataType( dataType );
}}}


Then the Comment class:

{{{
var dataType = {
	name: 'Comment',
	inheritedDataTypeId: model.getDataTypeIdByName( 'Object' ),
	fields: [
		{ name: 'title', dataTypeId: model.getDataTypeIdByName( 'Text' ), min: 0, max: 1, unique: false, preview: true },
		{ name: 'body', dataTypeId: model.getDataTypeIdByName( 'Text' ), min: 0, max: 1, unique: false, preview: false }
	]
}
model.createOrUpdateDataType( dataType );
}}}

And the Article class:

{{{
var dataType = {
	name: 'Article',
	inheritedDataTypeId: model.getDataTypeIdByName( 'Object' ),
	fields: [
		{ name: 'title', dataTypeId: model.getDataTypeIdByName( 'Text' ), min: 1, max: 1, unique: false, preview: true },
		{ name: 'topic', dataTypeId: model.getDataTypeIdByName( 'Topic' ), relationPath: '/topics', min: 1, max: 1, unique: false, preview: false },
		{ name: 'abstract', dataTypeId: model.getDataTypeIdByName( 'Text' ), min: 0, max: 1, unique: false, preview: false },
		{ name: 'body', dataTypeId: model.getDataTypeIdByName( 'Text' ), min: 0, max: 1, unique: false, preview: false },
		{ name: 'comments', dataTypeId: model.getDataTypeIdByName( 'Comment' ), min: 0, max: 1000, unique: false, preview: false }
	]
}
model.createOrUpdateDataType( dataType );
}}}

As you can see here, we define the relation topic and comments relations just as any primitive field.



= Create Admin Forms =

You can check JS the sources for the [http://code.google.com/p/ndjin/source/browse/trunk/js/blog/admin/formTopic.html topic] and [http://code.google.com/p/ndjin/source/browse/trunk/js/blog/admin/formArticle.html article] form.



We focus on Article creation function:
{{{
function createArticle( articleTitle, articleTopic, articleAbstract, articleBody )
{
	var query = 
	{ 
		ownerFieldName: 'articles',
		appliedTransitionNames: ['New', 'Store'],
		instance: 
		{
			title: articleTitle,
			abstract: articleAbstract,
			body: articleBody,
			topic: articleTopic
		},
		deepUpdateFieldNames: ['topic']
	};
	
	instanceHelper.callBackApplyTransition( query, function(data, textStatus)
	{
		loadArticles();					
	}
	);
}
}}}

Here you can see that we specify a `deepUpdateFieldNames` to allow the creation of an article and the link of the selected topic at the same time.




= Create Main View Page =


You can check JS the source [http://code.google.com/p/ndjin/source/browse/trunk/js/blog/index.html here].


We focus on article list query:

{{{
query = 
{
	ownerFieldName: "articles",
	count: 100,
	deepFieldNames: ['comments', 'body']
};
instanceHelper.callbackInstances( query, function (data, textStatus)
{
	/// ...
}}}}

Here you can see that we specify a `deepFieldNames ` to fetch in one query all the comments and body fields. 
By default each relation instance get only the field set as 'preview' fetched.

